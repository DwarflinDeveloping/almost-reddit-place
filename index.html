<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Almost Reddit Place</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Quicksand", sans-serif;
      }
      .custom-bg {
        background-color: linear-gradient(180deg, #f02e65 0%, #c81b4c 100%);
        background-image: url("/assets/bg.png");
        background-position: center;
        background-size: cover;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/appwrite@7.0.0"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js"
      integrity="sha512-NxocnqsXP3zm0Xb42zqVMvjQIktKEpTIbCXXyhBPxqGZHqhcOXHs4pXI/GoZ8lE+2NJONRifuBpi9DxC58L0Lw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      // You can define variable here with configurations for the application
      /*
      var globalConfig = {
        pixelsX: 10,
        pixelsY: 10
      }
      */
    </script>

    <script defer>
      var globalConfig = globalConfig || {};

      const appwrite = new Appwrite();

      appwrite
        .setEndpoint("https://appwrite.matejbaco.eu/v1")
        .setProject("almostRedditPlace");

      function alpineSetup() {
        return {
          config: Object.assign(
            {},
            {
              scaleLevels: [0.1, 0.2, 0.5, 1, 2, 3, 4, 5, 7, 9, 10],

              pixelsX: 100,
              pixelsY: 50,

              colors: ["#f02e65", "#ffffff", "#000000"],

              pixelSize: 10,
              pixelStokeSize: 1,
              pixelStrokeLength: 3,
            },
            globalConfig
          ),

          state: {
            isReady: false,
            scaleLevel: 3, // Index, from 0.
            positionX: 0,
            positionY: 0,

            debounce: null,

            selectedColor: "#f02e65",

            pixels: {},
          },

          p5: null,
          canvas: null,
          sketch: null,

          async onColorPixel() {
            if (this.state.isColoring) {
              return;
            }

            this.state.isColoring = true;

            try {
              const color = this.state.selectedColor;
              const pixel = this.getCurrentPixel();

              try {
                await appwrite.account.get();
              } catch (err) {
                await appwrite.account.createAnonymousSession();
              }

              const res = await appwrite.functions.createExecution(
                "colorPixel",
                JSON.stringify({
                  x: pixel.x,
                  y: pixel.y,
                  hex: color,
                }),
                false
              );

              if (res.stderr) {
                throw new Error(res.stderr);
              }

              const resJson = JSON.parse(
                decodeURIComponent(escape(res.stdout))
              );

              if (!resJson.success && resJson.message) {
                throw new Error(resJson.message);
              }
            } catch (err) {
              console.error(err);
              alert(err.message);
            } finally {
              this.state.isColoring = false;
            }
          },

          // Utility function
          scaled(x, invert = false, customRounding = null) {
            let scale = this.config.scaleLevels[this.state.scaleLevel];

            if (invert) {
              scale = scale / (scale * scale);
            }

            return customRounding
              ? customRounding(x * scale)
              : Math.floor(x * scale);
          },

          getCurrentPixel(pos = {}) {
            if (!pos.x) {
              pos.x = this.sketch.width / 2;
            }

            if (!pos.y) {
              pos.y = this.sketch.height / 2;
            }

            const scaled = this.scaled.bind(this);

            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            const mousePosX =
              -scaled(positionX) + (pos.x - scaled(pixelStokeSize) / 2);
            const mousePosY =
              -scaled(positionY) + (pos.y - scaled(pixelStokeSize) / 2);

            const currentPixelX = Math.floor(mousePosX / scaled(pixelSize));
            const currentPixelY = Math.floor(mousePosY / scaled(pixelSize));

            const currentPixel = {
              x: currentPixelX,
              y: currentPixelY,

              left: scaled(currentPixelX) * pixelSize + scaled(positionX),
              top: scaled(currentPixelY) * pixelSize + scaled(positionY),
              right:
                scaled(currentPixelX) * pixelSize +
                scaled(positionX) +
                scaled(pixelSize),
              bottom:
                scaled(currentPixelY) * pixelSize +
                scaled(positionY) +
                scaled(pixelSize),
            };
            return currentPixel;
          },

          async fetchPixels() {
            documents = [];
            count = 1;

            do {
              const response = await appwrite.database.listDocuments(
                "pixelsPublic",
                [
                  "x.lesserEqual(" + this.config.pixelsX + ")",
                  "x.greaterEqual(0)",
                  "y.lesserEqual(" + this.config.pixelsY + ")",
                  "y.greaterEqual(0)",
                ],
                100,
                documents.length
              );

              documents.push(...response.documents);
              count = response.total;
            } while (documents.length < count);

            for (const document of documents) {
              if (!this.state.pixels[document.$id]) {
                if (document.hex === "ffffff") {
                  if (this.state.pixels[document.$id]) {
                    unset(this.state.pixels[document.$id]);
                  }
                } else {
                  this.state.pixels[document.$id] = "#" + document.hex;
                }
              }
            }

            this.render(true);
          },

          init() {
            appwrite.subscribe(
              ["collections.pixelsPublic.documents"],
              (event) => {
                if (
                  event.event === "database.documents.update" ||
                  event.event === "database.documents.create"
                ) {
                  if (event.payload === "ffffff") {
                    if (this.state.pixels[event.payload.$id]) {
                      unset(this.state.pixels[event.payload.$id]);
                    }
                  } else {
                    this.state.pixels[event.payload.$id] =
                      "#" + event.payload.hex;
                    this.render();
                  }
                }
              }
            );

            setTimeout(() => {
              const s = (sketch) => {
                sketch.setup = () => {
                  const width = document.getElementById("appboard").clientWidth;

                  var canvas = sketch.createCanvas(
                    width ? width : 1280,
                    width ? (width / 16) * 9 : 720
                  );

                  canvas.parent("appboard");

                  this.canvas = canvas;
                  this.sketch = sketch;

                  this.fetchPixels();
                };

                // DO NOT USE
                sketch.draw = () => {};

                sketch.mouseDragged = (event) => {
                  if (event.target.nodeName.toLowerCase() !== "canvas") {
                    return;
                  }

                  const scaled = this.scaled.bind(this);

                  this.state.positionX += scaled(
                    event.movementX,
                    true,
                    event.movementX < 0 ? Math.floor : Math.ceil
                  );
                  this.state.positionY += scaled(
                    event.movementY,
                    true,
                    event.movementY < 0 ? Math.floor : Math.ceil
                  );

                  // TODO: Support touch for mobile

                  if (
                    this.state.debounce === null ||
                    this.state.debounce < Date.now() - 1
                  ) {
                    this.render();
                    this.state.debounce = Date.now();
                  }
                };
              };

              this.p5 = new p5(s);
            }, 1);
          },

          zoomOut() {
            this.state.scaleLevel = Math.max(this.state.scaleLevel - 1, 0);
            this.render();
          },

          zoomIn() {
            this.state.scaleLevel = Math.min(
              this.state.scaleLevel + 1,
              this.config.scaleLevels.length - 1
            );
            this.render();
          },

          render(forced = false) {
            if (!forced && !this.state.isReady) {
              return;
            }

            this.state.isReady = true;

            this.renderBackgroud();
            this.renderPixels();
            this.renderCursor();
          },

          renderBackgroud() {
            const scaled = this.scaled.bind(this);
            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            this.sketch.background("#e2e8f0");

            this.sketch.noStroke();
            this.sketch.fill("#ffffff");
            this.sketch.rect(
              scaled(positionX),
              scaled(positionY),
              scaled(pixelsX * pixelSize),
              scaled(pixelsY * pixelSize)
            );
          },

          renderPixels() {
            this.sketch.noStroke();

            const scaled = this.scaled.bind(this);

            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            for (let x = 0; x < pixelsX; x++) {
              for (let y = 0; y < pixelsY; y++) {
                const color = pixels[`${x}_${y}`] || null;
                if (color) {
                  this.sketch.fill(color);
                  this.sketch.rect(
                    scaled(positionX + x * pixelSize),
                    scaled(positionY + y * pixelSize),
                    scaled(pixelSize),
                    scaled(pixelSize)
                  );
                }
              }
            }
          },
          renderCursor() {
            this.sketch.noStroke();

            const scaled = this.scaled.bind(this);
            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            const currentPixel = this.getCurrentPixel();

            this.sketch.fill("#475569");

            this.sketch.rect(
              currentPixel.left,
              currentPixel.top,
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStrokeLength),
              currentPixel.top,
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.bottom - scaled(pixelStokeSize),
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStrokeLength),
              currentPixel.bottom - scaled(pixelStokeSize),
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.top,
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStokeSize),
              currentPixel.top,
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.bottom - scaled(pixelStrokeLength),
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStokeSize),
              currentPixel.bottom - scaled(pixelStrokeLength),
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );
          },
        };
      }

      const app = alpineSetup();
    </script>
  </head>
  <body>
    <div x-data="app">
      <!-- 'Made with Appwrite' badge -->
      <a
        href="https://appwrite.io/"
        target="_blank"
        style="position: fixed; right: 18px; bottom: 18px; z-index: 999"
      >
        <img
          style="width: 130px"
          src="https://appwrite.io/images-ee/press/badge-white-box.svg"
          alt="Built with Appwrite"
        />
      </a>

      <div class="fixed inset-0 bg-primary custom-bg z-[5]"></div>

      <div class="relative z-10 flex flex-col min-h-screen px-3 min-w-screen">
        <div
          class="absolute bottom-0 left-0 w-full h-20 bg-gradient-to-t from-black to-primary opacity-10"
        ></div>

        <img
          class="absolute z-10 hidden left-10 bottom-10 sm:block"
          src="/assets/dots-bl.svg"
          alt=""
        />
        <img
          class="absolute z-10 hidden right-10 top-10 sm:block"
          src="/assets/dots-tr.svg"
          alt=""
        />

        <div
          class="relative z-20 flex flex-col items-center justify-center h-screen pb-20"
        >
          <div class="flex items-center mb-6 justify-center space-x-3">
            <h1 class="text-white font-bold text-3xl text-center">
              Almost Reddit Place
            </h1>

            <template hidden x-if="!state.isReady">
              <svg
                class="w-6 h-6 animate-spin text-white"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
            </template>
          </div>

          <div class="container bg-white rounded-xl overflow-hidden">
            <div class="relative">
              <div class="absolute top-4 right-4 flex flex-col space-y-4">
                <button
                  x-on:click="zoomIn()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"
                    />
                  </svg>
                </button>
                <button
                  x-on:click="zoomOut()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"
                    />
                  </svg>
                </button>
              </div>

              <div id="appboard"></div>
            </div>
          </div>

          <div
            class="mt-3 container bg-white rounded-xl p-4 grid grid-cols-12 gap-4"
          >
            <div
              class="overflow-x-auto col-span-8 flex flex-row space-x-3 items-center h-full"
            >
              <template x-for="(color, i) in config.colors" :key="i">
                <div class="relative flex items-center justify-center h-full">
                  <template x-if="state.selectedColor === color">
                    <div
                      class="pointer-events-none absolute left-0 top-0 h-full items-center w-full flex justify-center"
                    >
                      <div
                        class="p-[3px] rounded-full bg-slate-900 border-white flex items-center justify-center text-white"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          class="h-3 w-3"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                          stroke-width="2"
                        >
                          <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M5 13l4 4L19 7"
                          />
                        </svg>
                      </div>
                    </div>
                  </template>

                  <button
                    x-on:click="state.selectedColor = color"
                    x-bind:class="state.selectedColor === color ? 'border-2 border-slate-900' : 'border border-slate-200'"
                    class="rounded-full w-10 h-10"
                    x-bind:style="'background-color:' + color"
                  ></button>
                </div>
              </template>
            </div>

            <div class="col-span-4">
              <button
                x-on:click="onColorPixel()"
                class="flex items-center justify-center space-x-3 text-white bg-[#f02e65] w-full rounded-xl py-3 px-9"
              >
                <p>Color Pixel</p>

                <template hidden x-if="state.isColoring">
                  <svg
                    class="w-4 h-4 animate-spin text-white"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                  >
                    <circle
                      class="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      stroke-width="4"
                    ></circle>
                    <path
                      class="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    ></path>
                  </svg>
                </template>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
