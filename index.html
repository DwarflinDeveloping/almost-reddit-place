<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Almost Reddit Place</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Quicksand", sans-serif;
      }
      .custom-bg {
        background-color: linear-gradient(180deg, #f02e65 0%, #c81b4c 100%);
        background-image: url("/assets/bg.png");
        background-position: center;
        background-size: cover;
      }
    </style>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js"
      integrity="sha512-NxocnqsXP3zm0Xb42zqVMvjQIktKEpTIbCXXyhBPxqGZHqhcOXHs4pXI/GoZ8lE+2NJONRifuBpi9DxC58L0Lw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script defer>
      function alpineSetup() {
        return {
          state: {
            // TODO: Move some to config
            isReady: false,
            scaleLevel: 8, // Index, from 0. Production: 3
            positionX: 0,
            positionY: 0,
            pixelsX: 100,
            pixelsY: 50,

            colors: [
              "red",
              "pink",
              "blue",
              "purple",
              "yellow",
              "white",
              "black",
              "black",
              "black",
              "black",
              "black",
              "black",
              "black",
              "black",
              "black",
              "black",
              "black",
            ],

            selectedColor: "red",

            pixelSize: 10,
            pixelStokeSize: 1,
            pixelStrokeLength: 3,

            pixels: {
              "0_0": "red",
              "1_0": "green",
              "2_0": "blue",
              "1_1": "pink",
            },
          },

          scaleLevels: [0.1, 0.2, 0.5, 1, 2, 3, 4, 5, 7, 9, 10],

          p5: null,
          canvas: null,
          sketch: null,

          onColorPixel() {
            const color = this.state.selectedColor;
            const pixel = this.getCurrentPixel();
            this.state.pixels[`${pixel.x}_${pixel.y}`] = color;
            this.render();
          },

          // Utility function
          scaled(x, invert = false, customRounding = null) {
            let scale = this.scaleLevels[this.state.scaleLevel];

            if (invert) {
              scale = scale / (scale * scale);
            }

            return customRounding
              ? customRounding(x * scale)
              : Math.floor(x * scale);
          },

          getCurrentPixel() {
            const scaled = this.scaled.bind(this);

            const {
              pixelsX,
              pixelsY,
              pixels,
              positionX,
              positionY,
              pixelSize,
              pixelStrokeLength,
              pixelStokeSize,
            } = this.state;

            const mousePosX =
              -scaled(positionX) +
              (this.sketch.width / 2 - scaled(pixelStokeSize) / 2);
            const mousePosY =
              -scaled(positionY) +
              (this.sketch.height / 2 - scaled(pixelStokeSize) / 2);

            const currentPixelX = Math.floor(mousePosX / scaled(pixelSize));
            const currentPixelY = Math.floor(mousePosY / scaled(pixelSize));

            const currentPixel = {
              x: currentPixelX,
              y: currentPixelY,

              left: scaled(currentPixelX) * pixelSize + scaled(positionX),
              top: scaled(currentPixelY) * pixelSize + scaled(positionY),
              right:
                scaled(currentPixelX) * pixelSize +
                scaled(positionX) +
                scaled(pixelSize),
              bottom:
                scaled(currentPixelY) * pixelSize +
                scaled(positionY) +
                scaled(pixelSize),
            };
            return currentPixel;
          },

          init() {
            setTimeout(() => {
              const s = (sketch) => {
                sketch.setup = () => {
                  const width = document.getElementById("appboard").clientWidth;

                  var canvas = sketch.createCanvas(
                    width ? width : 1280,
                    width ? (width / 16) * 9 : 720
                  );

                  canvas.parent("appboard");

                  this.canvas = canvas;
                  this.sketch = sketch;

                  this.render(true);
                };

                // DO NOT USE
                sketch.draw = () => {};

                sketch.mouseDragged = (event) => {
                  if (event.target.nodeName.toLowerCase() !== "canvas") {
                    return;
                  }

                  const scaled = this.scaled.bind(this);

                  this.state.positionX += scaled(
                    event.movementX,
                    true,
                    event.movementX < 0 ? Math.floor : Math.ceil
                  );
                  this.state.positionY += scaled(
                    event.movementY,
                    true,
                    event.movementY < 0 ? Math.floor : Math.ceil
                  );
                  this.render();
                };

                sketch.mouseMoved = (event) => {
                  if (event.target.nodeName.toLowerCase() !== "canvas") {
                    return;
                  }

                  // TODO: Only render if current pixel position changed
                  this.render();
                };
              };

              this.p5 = new p5(s);
            }, 1);
          },

          zoomOut() {
            this.state.scaleLevel = Math.max(this.state.scaleLevel - 1, 0);
            this.render();
          },

          zoomIn() {
            this.state.scaleLevel = Math.min(
              this.state.scaleLevel + 1,
              this.scaleLevels.length - 1
            );
            this.render();
          },

          render(forced = false) {
            if (!forced && !this.state.isReady) {
              return;
            }

            this.state.isReady = true;

            this.renderBackgroud();
            this.renderPixels();
            this.renderCursor();
          },

          renderBackgroud() {
            const scaled = this.scaled.bind(this);

            const {
              pixelsX,
              pixelsY,
              pixels,
              positionX,
              positionY,
              pixelSize,
            } = this.state;

            this.sketch.background("#e2e8f0");

            this.sketch.noStroke();
            this.sketch.fill("#f1f5f9");
            this.sketch.rect(
              scaled(positionX),
              scaled(positionY),
              scaled(pixelsX * pixelSize),
              scaled(pixelsY * pixelSize)
            );
          },

          renderPixels() {
            this.sketch.noStroke();

            const scaled = this.scaled.bind(this);

            const {
              pixelsX,
              pixelsY,
              pixels,
              positionX,
              positionY,
              pixelSize,
              pixelStrokeLength,
              pixelStokeSize,
            } = this.state;

            for (let x = 0; x < pixelsX; x++) {
              for (let y = 0; y < pixelsY; y++) {
                const color = pixels[`${x}_${y}`] || null;
                if (color) {
                  this.sketch.fill(color);
                  this.sketch.rect(
                    scaled(positionX + x * pixelSize),
                    scaled(positionY + y * pixelSize),
                    scaled(pixelSize),
                    scaled(pixelSize)
                  );
                }
              }
            }
          },
          renderCursor() {
            this.sketch.noStroke();

            const scaled = this.scaled.bind(this);

            const {
              pixelsX,
              pixelsY,
              pixels,
              positionX,
              positionY,
              pixelSize,
              pixelStrokeLength,
              pixelStokeSize,
            } = this.state;

            const currentPixel = this.getCurrentPixel();

            this.sketch.fill("#475569");

            this.sketch.rect(
              currentPixel.left,
              currentPixel.top,
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStrokeLength),
              currentPixel.top,
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.bottom - scaled(pixelStokeSize),
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStrokeLength),
              currentPixel.bottom - scaled(pixelStokeSize),
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.top,
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStokeSize),
              currentPixel.top,
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.bottom - scaled(pixelStrokeLength),
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStokeSize),
              currentPixel.bottom - scaled(pixelStrokeLength),
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );
          },
        };
      }

      const app = alpineSetup();
    </script>
  </head>
  <body>
    <div x-data="app">
      <!-- 'Made with Appwrite' badge -->
      <a
        href="https://appwrite.io/"
        target="_blank"
        style="position: fixed; right: 18px; bottom: 18px; z-index: 999"
      >
        <img
          style="width: 130px"
          src="https://appwrite.io/images-ee/press/badge-white-box.svg"
          alt="Built with Appwrite"
        />
      </a>

      <div class="fixed inset-0 bg-primary custom-bg z-[5]"></div>

      <div class="relative z-10 flex flex-col min-h-screen px-3 min-w-screen">
        <div
          class="absolute bottom-0 left-0 w-full h-20 bg-gradient-to-t from-black to-primary opacity-10"
        ></div>

        <img
          class="absolute z-10 hidden left-10 bottom-10 sm:block"
          src="/assets/dots-bl.svg"
          alt=""
        />
        <img
          class="absolute z-10 hidden right-10 top-10 sm:block"
          src="/assets/dots-tr.svg"
          alt=""
        />

        <div
          class="relative z-20 flex flex-col items-center justify-center h-screen pb-20"
        >
          <h1 class="text-white mb-6 font-bold text-3xl text-center">
            Almost Reddit Place
          </h1>

          <div class="container bg-white rounded-xl overflow-hidden">
            <div class="relative">
              <div class="absolute top-4 right-4 flex flex-col space-y-4">
                <button
                  x-on:click="zoomIn()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"
                    />
                  </svg>
                </button>
                <button
                  x-on:click="zoomOut()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"
                    />
                  </svg>
                </button>
              </div>

              <div id="appboard"></div>
            </div>
          </div>

          <div
            class="mt-3 container bg-white rounded-xl p-4 grid grid-cols-12 gap-4"
          >
            <div
              class="overflow-x-auto col-span-8 flex flex-row space-x-3 items-center h-full"
            >
              <template x-for="(color, i) in state.colors" :key="i">
                <div class="relative flex items-center justify-center h-full">
                  <template x-if="state.selectedColor === color">
                    <div
                      class="pointer-events-none absolute left-0 top-0 h-full items-center w-full flex justify-center"
                    >
                      <div
                        class="p-[3px] rounded-full bg-slate-900 border-white flex items-center justify-center text-white"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          class="h-3 w-3"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                          stroke-width="2"
                        >
                          <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M5 13l4 4L19 7"
                          />
                        </svg>
                      </div>
                    </div>
                  </template>

                  <button
                    x-on:click="state.selectedColor = color"
                    x-bind:class="state.selectedColor === color ? 'border-2 border-slate-900' : 'border border-slate-200'"
                    class="rounded-full w-10 h-10"
                    x-bind:style="'background-color:' + color"
                  ></button>
                </div>
              </template>
            </div>

            <div class="col-span-4">
              <button
                x-on:click="onColorPixel()"
                class="text-white bg-[#f02e65] w-full rounded-xl py-3 px-9"
              >
                Color Pixel
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
