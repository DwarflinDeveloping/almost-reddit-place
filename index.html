<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Almost Reddit Place</title>

    <link rel="icon" type="image/x-icon" href="/favicon.ico" />

    <meta
      name="description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="almost-reddit-place.vercel.app" />
    <meta
      property="twitter:url"
      content="https://almost-reddit-place.vercel.app/"
    />
    <meta name="twitter:title" content="Almost Reddit Place" />
    <meta
      name="twitter:description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />
    <meta
      name="twitter:image"
      content="https://almost-reddit-place.vercel.app/cover.png"
    />

    <meta property="og:title" content="Almost Reddit Place" />
    <meta property="og:site_name" content="Almost Reddit Place" />
    <meta property="og:url" content="https://almost-reddit-place.vercel.app/" />
    <meta
      property="og:description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://almost-reddit-place.vercel.app/cover.png"
    />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Quicksand", sans-serif;
        overscroll-behavior: contain;
      }
      .custom-bg {
        background-color: linear-gradient(180deg, #f02e65 0%, #c81b4c 100%);
        background-image: url("/assets/bg.png");
        background-position: center;
        background-size: cover;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/appwrite@7.0.0"></script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js"
      integrity="sha512-NxocnqsXP3zm0Xb42zqVMvjQIktKEpTIbCXXyhBPxqGZHqhcOXHs4pXI/GoZ8lE+2NJONRifuBpi9DxC58L0Lw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script>
      window.authModal = {
        adapter: "appwrite",
        config: {
          endpoint: "https://appwrite.matejbaco.eu/v1",
          projectId: "almostRedditPlaceV2",
        },

        // If using Uauth
        oauths: [],
        oauthSuccessUrl: window.location.origin + "/",
        oauthErrorUrl: window.location.origin + "/",

        // If using Magic URL
        magicUrlRedirect: window.location.origin + "/",

        // If supporting password recovery
        passwordRecoveryRedirect: window.location.origin + "/",
      };
    </script>
    <!-- Auth Modal -->
    <script src="/auth-modal.js" defer></script>

    <script>
      // You can define variable here with configurations for the application
      /*
      var globalConfig = {
        pixelsX: 10,
        pixelsY: 10
      }
      */
    </script>

    <script defer>
      var globalConfig = globalConfig || {};

      const appwrite = new Appwrite();

      appwrite
        .setEndpoint("https://appwrite.matejbaco.eu/v1")
        .setProject("almostRedditPlaceV2");

      function alpineSetup() {
        return {
          config: Object.assign(
            {},
            {
              scaleLevels: [0.1, 0.2, 0.5, 1, 2, 3, 4, 5, 7, 9, 10],

              delaySeconds: 10,

              pixelsX: 500,
              pixelsY: 500,

              colors: [
                "#ff0000",
                "#ff8700",
                "#ffd300",
                "#deff0a",
                "#a1ff0a",
                "#0aff99",
                "#0aefff",
                "#147df5",
                "#580aff",
                "#be0aff",
                "#ffffff",
                "#000000",
              ],

              pixelSize: 10,
              pixelStokeSize: 1,
              pixelStrokeLength: 3,
            },
            globalConfig
          ),

          state: {
            showInfoAlert: false,

            cooldown: null,
            interval: null,

            currentPixelData: null,
            currentPixelShow: false,

            touch: {
              clientY: null,
              clientX: null,
            },

            isReady: false,
            scaleLevel: 3, // Index, from 0.
            positionX: 0,
            positionY: 0,

            debounce: null,

            selectedColor: "#ff0000",

            pixels: {},
          },

          p5: null,
          canvas: null,
          sketch: null,

          async onColorPixel() {
            if (this.state.isColoring) {
              return;
            }

            this.state.isColoring = true;

            try {
              const color = this.state.selectedColor;
              const pixel = this.getCurrentPixel();

              try {
                await appwrite.account.get();
              } catch (err) {
                throw new Error("To place pixels, you must sign in.");
              }

              const res = await appwrite.functions.createExecution(
                "colorPixel",
                JSON.stringify({
                  x: pixel.x,
                  y: pixel.y,
                  hex: color,
                }),
                false
              );

              if (res.stderr) {
                throw new Error(res.stderr);
              }

              const resJson = JSON.parse(
                decodeURIComponent(escape(res.stdout))
              );

              if (!resJson.success && resJson.message) {
                throw new Error(resJson.message);
              }

              if (resJson.skipDelay) {
                this.state.cooldown = 0;
                if (this.state.interval) {
                  clearInterval(this.state.interval);
                }
              } else {
                this.state.cooldown = this.config.delaySeconds;
                if (this.state.interval) {
                  clearInterval(this.state.interval);
                }
                this.state.interval = setInterval(() => {
                  this.state.cooldown--;

                  if (this.state.cooldown <= 0) {
                    if (this.state.interval) {
                      clearInterval(this.state.interval);
                    }
                  }
                }, 1000);
              }
            } catch (err) {
              console.error(err);
              if (err.message === "Too many requests") {
                err.message =
                  "You are too quick! You are not allowed to continue for a minute.";
              }
              alert(err.message);
            } finally {
              this.state.isColoring = false;
            }
          },

          // Utility function
          scaled(x, invert = false, customRounding = null) {
            let scale = this.config.scaleLevels[this.state.scaleLevel];

            if (invert) {
              scale = scale / (scale * scale);
            }

            return customRounding
              ? customRounding(x * scale)
              : Math.floor(x * scale);
          },

          getCurrentPixel(pos = {}) {
            if (!pos.x) {
              pos.x = this.sketch.width / 2;
            }

            if (!pos.y) {
              pos.y = this.sketch.height / 2;
            }

            const scaled = this.scaled.bind(this);

            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            const mousePosX =
              -scaled(positionX) + (pos.x - scaled(pixelStokeSize) / 2);
            const mousePosY =
              -scaled(positionY) + (pos.y - scaled(pixelStokeSize) / 2);

            const currentPixelX = Math.floor(mousePosX / scaled(pixelSize));
            const currentPixelY = Math.floor(mousePosY / scaled(pixelSize));

            const pixel =
              this.state.pixels[`${currentPixelX}_${currentPixelY}`];
            if (pixel) {
              this.state.currentPixelData = pixel;
              this.state.currentPixelShow = true;
            } else {
              // this.state.currentPixelData = null;
              this.state.currentPixelShow = false;
            }

            const currentPixel = {
              x: currentPixelX,
              y: currentPixelY,

              left: scaled(currentPixelX) * pixelSize + scaled(positionX),
              top: scaled(currentPixelY) * pixelSize + scaled(positionY),
              right:
                scaled(currentPixelX) * pixelSize +
                scaled(positionX) +
                scaled(pixelSize),
              bottom:
                scaled(currentPixelY) * pixelSize +
                scaled(positionY) +
                scaled(pixelSize),
            };
            return currentPixel;
          },

          async fetchPixels() {
            documents = [];
            count = 1;

            do {
              const response = await appwrite.database.listDocuments(
                "pixelsPublic",
                [
                  "x.lesserEqual(" + this.config.pixelsX + ")",
                  "x.greaterEqual(0)",
                  "y.lesserEqual(" + this.config.pixelsY + ")",
                  "y.greaterEqual(0)",
                ],
                100,
                documents.length
              );

              documents.push(...response.documents);
              count = response.total;
            } while (documents.length < count);
            for (const document of documents) {
              if (!this.state.pixels[document.$id]) {
                if (document.hex === "ffffff") {
                  if (this.state.pixels[document.$id]) {
                    delete this.state.pixels[document.$id];
                  }
                } else {
                  this.state.pixels[document.$id] = document;
                }
              }
            }

            this.render(true);
          },

          init() {
            appwrite.subscribe(
              ["collections.pixelsPublic.documents"],
              (event) => {
                if (
                  event.event === "database.documents.update" ||
                  event.event === "database.documents.create"
                ) {
                  if (event.payload.hex === "ffffff") {
                    if (this.state.pixels[event.payload.$id]) {
                      delete this.state.pixels[event.payload.$id];
                    }
                  } else {
                    this.state.pixels[event.payload.$id] = event.payload;
                  }

                  this.render();
                }
              }
            );

            setTimeout(() => {
              const s = (sketch) => {
                sketch.setup = () => {
                  const width = document.getElementById("appboard").clientWidth;

                  var canvas = sketch.createCanvas(
                    width ? width : 1280,
                    width ? (width / 16) * 9 : 720
                  );

                  canvas.parent("appboard");

                  this.canvas = canvas;
                  this.sketch = sketch;

                  this.fetchPixels();
                };

                // DO NOT USE
                sketch.draw = () => {};

                sketch.keyPressed = (event) => {
                  if (
                    event.target.nodeName.toLowerCase() !== "canvas" &&
                    event.target.nodeName.toLowerCase() !== "body"
                  ) {
                    return;
                  }

                  if (event.key === " ") {
                    this.onColorPixel();
                    return;
                  }

                  if (!isNaN(event.key)) {
                    const colorIndex = +event.key - 1;
                    this.state.selectedColor = this.config.colors[colorIndex];
                    return;
                  }

                  let moveX = 0;
                  let moveY = 0;

                  if (
                    event.key === "A" ||
                    event.key === "a" ||
                    event.key === "ArrowLeft"
                  ) {
                    moveX = +this.config.pixelSize;
                  }

                  if (
                    event.key === "D" ||
                    event.key === "d" ||
                    event.key === "ArrowRight"
                  ) {
                    moveX = -this.config.pixelSize;
                  }

                  if (
                    event.key === "W" ||
                    (event.key === "w") | (event.key === "ArrowUp")
                  ) {
                    moveY = +this.config.pixelSize;
                  }

                  if (
                    event.key === "S" ||
                    event.key === "s" ||
                    event.key === "ArrowDown"
                  ) {
                    moveY = -this.config.pixelSize;
                  }

                  if (event.shiftKey) {
                    moveX *= 3;
                    moveY *= 3;
                  }

                  this.state.positionX += moveX;
                  this.state.positionY += moveY;

                  if (moveX !== 0 || moveY !== 0) {
                    this.render();
                  }
                };

                sketch.mouseReleased = (event) => {
                  this.state.touch.clientX = null;
                  this.state.touch.clientY = null;
                };

                sketch.mouseDragged = (event) => {
                  event.stopPropagation();
                  event.preventDefault();

                  if (event.target.nodeName.toLowerCase() !== "canvas") {
                    return;
                  }

                  if (event.type === "touchmove") {
                    const difX =
                      this.state.touch.clientX === null
                        ? 0
                        : this.state.touch.clientX - event.touches[0].clientX;
                    const difY =
                      this.state.touch.clientY === null
                        ? 0
                        : this.state.touch.clientY - event.touches[0].clientY;

                    event.movementX = -difX;
                    event.movementY = -difY;

                    this.state.touch.clientX = event.touches[0].clientX;
                    this.state.touch.clientY = event.touches[0].clientY;
                  }

                  const scaled = this.scaled.bind(this);

                  this.state.positionX += scaled(
                    event.movementX,
                    true,
                    event.movementX < 0 ? Math.floor : Math.ceil
                  );
                  this.state.positionY += scaled(
                    event.movementY,
                    true,
                    event.movementY < 0 ? Math.floor : Math.ceil
                  );

                  if (
                    this.state.debounce === null ||
                    this.state.debounce < Date.now() - 1
                  ) {
                    this.render();
                    this.state.debounce = Date.now();
                  }
                };
              };

              this.p5 = new p5(s);
            }, 1);
          },

          repositionZoom(fromIndex, toIndex) {
            // TODO: Reposition zoom to middle using positionX and this.sketch.width
          },

          toggleInfo() {
            this.state.showInfoAlert = !this.state.showInfoAlert;
          },

          zoomOut() {
            const currentLevel = this.state.scaleLevel;
            this.state.scaleLevel = Math.max(this.state.scaleLevel - 1, 0);

            this.repositionZoom(currentLevel, this.state.scaleLevel);

            this.render();
          },

          zoomIn() {
            const currentLevel = this.state.scaleLevel;
            this.state.scaleLevel = Math.min(
              this.state.scaleLevel + 1,
              this.config.scaleLevels.length - 1
            );

            this.repositionZoom(currentLevel, this.state.scaleLevel);

            this.render();
          },

          render(forced = false) {
            if (!forced && !this.state.isReady) {
              return;
            }

            this.state.isReady = true;

            this.renderBackgroud();
            this.renderPixels();
            this.renderCursor();
          },

          renderBackgroud() {
            const scaled = this.scaled.bind(this);
            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            this.sketch.background("#e2e8f0");

            this.sketch.noStroke();
            this.sketch.fill("#ffffff");
            this.sketch.rect(
              scaled(positionX),
              scaled(positionY),
              scaled(pixelsX * pixelSize),
              scaled(pixelsY * pixelSize)
            );
          },

          printDate(date) {
            if (!date) {
              return "No date";
            }

            const d = new Date(date);

            const min =
              d.getMinutes() < 10 ? "0" + d.getMinutes() : d.getMinutes();
            const hour = d.getHours() < 10 ? "0" + d.getHours() : d.getHours();
            const day = d.getDate() < 10 ? "0" + d.getDate() : d.getDate();
            let m = d.getMonth() + 1;
            const month = m < 10 ? "0" + m : m;

            return `${day}.${month} at ${hour}:${min}`;
          },

          renderPixels() {
            this.sketch.noStroke();

            const scaled = this.scaled.bind(this);

            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            const render = {};

            const customRounding = (t) => t;
            const screen = {};
            screen.minX = Math.round(-positionX / pixelSize) - 1;
            screen.minY = Math.round(-positionY / pixelSize) - 1;
            screen.maxX =
              screen.minX +
              Math.round(
                this.sketch.width / scaled(pixelSize, false, customRounding)
              ) +
              1;
            screen.maxY =
              screen.minY +
              Math.round(
                this.sketch.height / scaled(pixelSize, false, customRounding)
              ) +
              1;

            for (const pixel in pixels) {
              const color = pixels[pixel].hex;
              const pixelData = pixel.split("_");
              const pX = +pixelData[0];
              const pY = +pixelData[1];

              if (
                pX < screen.minX ||
                pY < screen.minY ||
                pX > screen.maxX ||
                pY > screen.maxY
              ) {
                continue;
              }

              if (!render[color]) {
                render[color] = {};
              }

              render[color][`${pX}_${pY}`] = true;
            }

            const banList = {};

            for (const hex in render) {
              this.sketch.fill("#" + hex);
              for (const pos in render[hex]) {
                if (banList[pos]) {
                  continue;
                }

                const posArr = pos.split("_");
                const posX = +posArr[0];
                const posY = +posArr[1];

                let widthPlus = 0;
                let widthMinus = 0;
                let posXTmp;

                posXTmp = posX + 1;
                while (render[hex][`${posXTmp}_${posY}`]) {
                  banList[`${posXTmp}_${posY}`] = true;
                  widthPlus++;
                  posXTmp++;
                }

                posXTmp = posX - 1;
                while (render[hex][`${posXTmp}_${posY}`]) {
                  banList[`${posXTmp}_${posY}`] = true;
                  widthMinus++;
                  posXTmp--;
                }

                this.sketch.rect(
                  scaled(positionX + (posX - widthMinus) * pixelSize),
                  scaled(positionY + posY * pixelSize),
                  scaled(pixelSize) * (1 + widthPlus + widthMinus),
                  scaled(pixelSize)
                );
              }
            }
          },
          renderCursor() {
            this.sketch.noStroke();

            const scaled = this.scaled.bind(this);
            const { pixels, positionX, positionY } = this.state;

            const {
              pixelsX,
              pixelsY,
              pixelStrokeLength,
              pixelStokeSize,
              pixelSize,
            } = this.config;

            const currentPixel = this.getCurrentPixel();

            this.sketch.fill("#475569");

            this.sketch.rect(
              currentPixel.left,
              currentPixel.top,
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStrokeLength),
              currentPixel.top,
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.bottom - scaled(pixelStokeSize),
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStrokeLength),
              currentPixel.bottom - scaled(pixelStokeSize),
              scaled(pixelStrokeLength),
              scaled(pixelStokeSize)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.top,
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStokeSize),
              currentPixel.top,
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.left,
              currentPixel.bottom - scaled(pixelStrokeLength),
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );

            this.sketch.rect(
              currentPixel.right - scaled(pixelStokeSize),
              currentPixel.bottom - scaled(pixelStrokeLength),
              scaled(pixelStokeSize),
              scaled(pixelStrokeLength)
            );
          },
        };
      }

      const app = alpineSetup();
    </script>
  </head>
  <body>
    <a
      class="hidden md:block"
      href="https://github.com/Meldiron/almost-reddit-place"
    >
      <img
        alt="Fork me on GitHub"
        data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
        src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67"
        style="position: absolute; top: 0; right: 0; border: 0; z-index: 100"
      />
    </a>

    <div x-data="app">
      <!-- 'Made with Appwrite' badge -->
      <a
        class="hidden md:block"
        href="https://appwrite.io/"
        target="_blank"
        style="position: fixed; right: 18px; bottom: 18px; z-index: 999"
      >
        <img
          style="width: 130px"
          src="https://appwrite.io/images-ee/press/badge-white-box.svg"
          alt="Built with Appwrite"
        />
      </a>

      <div class="fixed inset-0 bg-primary custom-bg z-[5]"></div>

      <div class="relative z-10 flex flex-col min-h-screen px-3 min-w-screen">
        <div
          class="absolute bottom-0 left-0 w-full h-20 bg-gradient-to-t from-black to-primary opacity-10"
        ></div>

        <img
          class="absolute z-10 hidden left-10 bottom-10 sm:block"
          src="/assets/dots-bl.svg"
          alt=""
        />
        <img
          class="absolute z-10 hidden right-10 top-10 sm:block"
          src="/assets/dots-tr.svg"
          alt=""
        />

        <div
          class="relative z-20 flex flex-col items-center justify-center h-screen pb-20"
        >
          <div class="flex items-center mb-6 justify-center space-x-3">
            <h1 class="text-white font-bold text-3xl text-center">
              Almost Reddit Place
            </h1>

            <template hidden x-if="!state.isReady">
              <svg
                class="w-6 h-6 animate-spin text-white"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
            </template>
          </div>

          <div
            class="touch-manipulation container bg-white rounded-xl overflow-hidden relative"
          >
            <div
              x-show="state.currentPixelShow"
              x-transition:enter="transition ease-out duration-300"
              x-transition:enter-start="opacity-0 scale-90"
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-300"
              x-transition:leave-start="opacity-100 scale-100"
              x-transition:leave-end="opacity-0 scale-90"
              class="pointer-events-none absolute -space-y-1 flex-col z-10 bottom-4 left-0 w-full flex items-center justify-center"
            >
              <div
                x-text="state.currentPixelData ? printDate(state.currentPixelData.createdAt) : ''"
                class="p-1 px-2 text-xs text-slate-200 bg-slate-500 rounded-lg"
              ></div>
              <div
                x-text="state.currentPixelData ? state.currentPixelData.userId : ''"
                class="p-2 text-sm text-slate-500 bg-slate-900 rounded-lg"
              ></div>
            </div>

            <div class="relative">
              <div class="absolute top-4 left-4 flex flex-col space-y-4">
                <button
                  x-on:click="toggleInfo()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                      clip-rule="evenodd"
                    />
                  </svg>
                </button>
              </div>

              <div class="absolute top-4 right-4 flex flex-col space-y-4">
                <button
                  x-on:click="zoomIn()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"
                    />
                  </svg>
                </button>
                <button
                  x-on:click="zoomOut()"
                  class="p-3 rounded-full bg-red-100 text-red-600 hover:bg-red-200"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"
                    />
                  </svg>
                </button>
              </div>

              <div id="appboard"></div>
            </div>
          </div>

          <div
            class="mt-3 container bg-white rounded-xl p-4 grid grid-cols-12 gap-4"
          >
            <div
              class="overflow-x-auto col-span-12 md:col-span-8 flex flex-row space-x-3 items-center h-full"
            >
              <template x-for="(color, i) in config.colors" :key="i">
                <div class="relative flex items-center justify-center h-full">
                  <template x-if="state.selectedColor === color">
                    <div
                      class="pointer-events-none absolute left-0 top-0 h-full items-center w-full flex justify-center"
                    >
                      <div
                        class="p-[3px] rounded-full bg-slate-900 border-white flex items-center justify-center text-white"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          class="h-3 w-3"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                          stroke-width="2"
                        >
                          <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M5 13l4 4L19 7"
                          />
                        </svg>
                      </div>
                    </div>
                  </template>

                  <button
                    x-on:click="state.selectedColor = color"
                    x-bind:class="state.selectedColor === color ? 'border-2 border-slate-900' : 'border border-slate-200'"
                    class="rounded-full w-10 h-10"
                    x-bind:style="'background-color:' + color"
                  ></button>
                </div>
              </template>
            </div>

            <template
              hidden
              x-data="{loaded: false}"
              x-init="setTimeout(() => { loaded = true }, 1)"
              x-if="loaded"
            >
              <div class="col-span-12 md:col-span-4">
                <template hidden x-if="$store.authModal.accountProfile">
                  <button
                    x-on:click="onColorPixel()"
                    x-bind:class="state.cooldown <= 0 ? 'bg-[#f02e65]' : 'bg-orange-400 opacity-50'"
                    class="flex items-center justify-center space-x-3 text-white bg-[#f02e65] w-full rounded-xl py-3 px-9"
                  >
                    <template x-if="state.cooldown <= 0"
                      ><p>Color Pixel</p></template
                    >
                    <template x-if="state.cooldown > 0"
                      ><p
                        x-text="'Color in ' + state.cooldown + (state.cooldown <= 1 ? ' second' : ' seconds')"
                      ></p
                    ></template>

                    <template hidden x-if="state.isColoring">
                      <svg
                        class="w-4 h-4 animate-spin text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          class="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          stroke-width="4"
                        ></circle>
                        <path
                          class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                    </template>
                  </button>
                </template>

                <template hidden x-if="!$store.authModal.accountProfile">
                  <button
                    x-on:click="$store.authModal.open()"
                    class="flex items-center justify-center space-x-3 text-white bg-[#f02e65] w-full rounded-xl py-3 px-9"
                  >
                    <p>Sign in to Color</p>

                    <template hidden x-if="state.isColoring">
                      <svg
                        class="w-4 h-4 animate-spin text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          class="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          stroke-width="4"
                        ></circle>
                        <path
                          class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                    </template>
                  </button>
                </template>
              </div>
            </template>
          </div>
        </div>
      </div>

      <div
        x-show="state.showInfoAlert"
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0"
        x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-300"
        x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0"
        class="fixed z-[9999] inset-0"
        style="display: none; font-family: 'Montserrat', sans-serif"
      >
        <div class="w-full h-full relative">
          <div
            class="absolute inset-0 bg-black opacity-50"
            x-on:click="toggleInfo()"
          ></div>
          <div
            class="relative w-full h-full pt-10 overflow-y-auto pb-10"
            x-on:click="toggleInfo()"
          >
            <div
              class="mx-auto w-full max-w-2xl rounded-xl bg-white p-6"
              x-on:click="$event.stopPropagation()"
            >
              <div class="flex justify-between items-center">
                <h1 class="text-auth-gray-900 mb-4 text-2xl font-bold">
                  Getting Started
                </h1>
                <button
                  type="button"
                  x-on:click="toggleInfo()"
                  class="p-3 transition-colors duration-200 transform rounded-md hover:bg-opacity-25 hover:bg-gray-600 focus:outline-none"
                >
                  <svg
                    class="w-5 h-5"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      d="M6 18L18 6M6 6L18 18"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    ></path>
                  </svg>
                </button>
              </div>
              <div class="mt-6 prose">
                <p>Welcome to Almost Reddit Place 👋</p>

                <p>
                  I decided to create this project to showcase what
                  <a
                    href="https://appwrite.io/docs/installation"
                    class="text-[#f02e65]"
                    >Appwrite</a
                  >
                  is capable of and learn how to work with canvas on a website.
                  I took the idea from Reddit Place, where the Reddit team added
                  a minigame similar to this one for a few weeks after April
                  Fools' Day 🤪
                </p>

                <p>
                  In this game, anyone can color 1 pixel of 2000x2000 canvas
                  every 10 seconds. There is a palette of colors you can pick
                  from to create your masterpiece. If you want to work on a big
                  painting, feel free to invite your friends to help you 🖼️
                </p>

                <i class="italic"
                  >Fun fact: Appwrite implementation took less than 2 hours!</i
                >

                <h3>✨ Tips and Tricks</h3>

                <ul>
                  <li>
                    Center of the canvas is your cursor. This means that if you
                    paint a pixel, it will paint the one in the middle of the
                    canvas. You can drag&drop with your mouse to move around the
                    canvas to move this cursor. The cursor is visible, so there
                    shouldn't be any problem painting any pixel you want. If it
                    feels tricky selecting a specific pixel, you can zoom in to
                    make it easier.
                  </li>
                  <li>
                    If you focus inside canvas (click it), you can now use WASD
                    (or arrows) to move around. Hold SHIFT to move 3 pixels
                    instead of one. You can also use numbers on the keyboard to
                    switch colors and press SPACE to paint the pixel.
                  </li>
                  <li>
                    If canvas lags on your device, you can zoom in. The more you
                    are zoomed-in, the fewer pixels your device needs to render,
                    the faster it is.
                  </li>
                  <li>
                    If you paint the pixel white, it resets the pixel. You won't
                    see your name on such a pixel, it will become an empty
                    pixel.
                  </li>
                  <li>
                    If you register, the first part of your email becomes your
                    username. The username is publicly visible, so feel free to
                    create a fake account if you don't want to share your email.
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
