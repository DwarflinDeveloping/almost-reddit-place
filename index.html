<!DOCTYPE html>
<html lang="en" x-init="initTheme()">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Almost Reddit Place</title>

    <link rel="icon" type="image/x-icon" href="/favicon.ico" />

    <meta
      name="description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta property="twitter:domain" content="almost-reddit-place.vercel.app" />
    <meta
      property="twitter:url"
      content="https://almost-reddit-place.vercel.app/"
    />
    <meta name="twitter:title" content="Almost Reddit Place" />
    <meta
      name="twitter:description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />
    <meta
      name="twitter:image"
      content="https://almost-reddit-place.vercel.app/cover.png"
    />

    <meta property="og:title" content="Almost Reddit Place" />
    <meta property="og:site_name" content="Almost Reddit Place" />
    <meta property="og:url" content="https://almost-reddit-place.vercel.app/" />
    <meta
      property="og:description"
      content="Reddit r/place canvas clone made customizable, open-sourced and self-hosted."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://almost-reddit-place.vercel.app/cover.png"
    />

    <!-- font related -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Quicksand", sans-serif;
      }

      .custom-bg {
        background-position: center;
        background-size: cover;
      }

      canvas {
        image-rendering: pixelated;
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
      }
    </style>

    <link rel="stylesheet" type="text/css" href="tailwind.css" />

    <script src="https://cdn.jsdelivr.net/npm/appwrite@7.0.0"></script>
    <script src="//unpkg.com/alpinejs" defer></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js"
      integrity="sha512-NxocnqsXP3zm0Xb42zqVMvjQIktKEpTIbCXXyhBPxqGZHqhcOXHs4pXI/GoZ8lE+2NJONRifuBpi9DxC58L0Lw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <script src="https://cdn.jsdelivr.net/gh/bgrins/TinyColor/dist/tinycolor-min.js"></script>

    <!-- theme related -->
    <script>
      function initTheme() {
        if (!('theme' in localStorage)) {
          localStorage.theme = 'light';
        }
        updateTheme()
      }

      function updateTheme() {
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark')
        } else {
          document.documentElement.classList.remove('dark')
        }
      }
    </script>

    <script>
      window.authModal = {
        adapter: "appwrite",
        config: {
          endpoint: "https://appwrite.matejbaco.eu/v1",
          projectId: "almostRedditPlaceV2",
        },

        // If using Uauth
        oauths: [],
        oauthSuccessUrl: window.location.origin + "/",
        oauthErrorUrl: window.location.origin + "/",

        // If using Magic URL
        magicUrlRedirect: window.location.origin + "/",

        // If supporting password recovery
        passwordRecoveryRedirect: window.location.origin + "/",
      };
    </script>
    <!-- Auth Modal -->
    <script src="/auth-modal.js" defer></script>

    <script defer>
      var globalConfig = globalConfig || {};

      const appwrite = new Appwrite();

      appwrite
        .setEndpoint("https://appwrite.matejbaco.eu/v1")
        .setProject("almostRedditPlaceV2");

      function alpineSetup() {
        return {
          config: Object.assign(
            {},
            {
              delaySeconds: 10,

              pixelsX: 500,
              pixelsY: 500,

              colors: [
                "#ff0000",
                "#ff8700",
                "#ffd300",
                "#ffe5b4",
                "#ffc0cb",
                "#deff0a",
                "#a1ff0a",
                "#0aff99",
                "#228B22",
                "#0aefff",
                "#147df5",
                "#580aff",
                "#be0aff",
                "#ffffff",
                "#000000",
                "#654321",
                "#808080",
              ],
            },
            globalConfig
          ),

          state: {
            showInfoAlert: false,

            cooldown: null,
            interval: null,

            isColoring: false,

            currentPixelData: null,
            currentPixelShow: false,

            touch: {
              clientY: null,
              clientX: null,
            },

            isReady: false,

            debounce: null,

            selectedColor: "#ff0000",

            zoom: 1,
            isDragging: false,
            overlaysHidden: false,

            currentPixelPos: null,

            lastTouch: null,

            posX: 0,
            posY: 0,

            previousPixelColor: null,
            previousPixelPosition: null,

            pixels: {},
          },

          p5: null,
          canvas: null,
          sketch: null,

          async onColorPixel() {
            if (this.state.isColoring || this.state.currentPixelPos === null) {
              return;
            }

            try {
              this.state.isColoring = true;

              const color = this.state.selectedColor;
              const pixel = {
                x: this.state.currentPixelPos[0],
                y: this.state.currentPixelPos[1],
              };

              try {
                await appwrite.account.get();
              } catch (err) {
                throw new Error("To place pixels, you must sign in.");
              }

              const res = await appwrite.functions.createExecution(
                "colorPixel",
                JSON.stringify({
                  x: pixel.x,
                  y: pixel.y,
                  hex: color,
                }),
                false
              );

              if (res.stderr) {
                throw new Error(res.stderr);
              }

              const resJson = JSON.parse(
                decodeURIComponent(escape(res.stdout))
              );

              if (!resJson.success && resJson.message) {
                throw new Error(resJson.message);
              }

              if (resJson.skipDelay) {
                this.state.cooldown = 0;
                if (this.state.interval) {
                  clearInterval(this.state.interval);
                }
              } else {
                this.state.cooldown = this.config.delaySeconds;
                if (this.state.interval) {
                  clearInterval(this.state.interval);
                }
                this.state.interval = setInterval(() => {
                  this.state.cooldown--;

                  if (this.state.cooldown <= 0) {
                    if (this.state.interval) {
                      clearInterval(this.state.interval);
                    }
                  }
                }, 1000);
              }
            } catch (err) {
              console.error(err);
              if (err.message === "Too many requests") {
                err.message =
                  "You are too quick! You are not allowed to continue for a minute.";
              }
              alert(err.message);
            } finally {
              this.state.isColoring = false;
            }
          },

          async fetchUsingStorage() {
            documents = [];

            const fileRes = await appwrite.storage.listFiles(
              "pixels",
              undefined,
              1,
              undefined,
              undefined,
              undefined,
              "DESC"
            );

            const fileUrl = appwrite.storage.getFileDownload(
              "pixels",
              fileRes.files[0].$id
            );

            const jsonText = await (await fetch(fileUrl.href)).text();

            const json = JSON.parse(jsonText.split("}]}")[0] + "}]}");

            documents = json.docs;

            let cursor = undefined;
            hasNext = true;
            do {
              const response = await appwrite.database.listDocuments(
                "pixelsPublic",
                [
                  "x.lesserEqual(" + this.config.pixelsX + ")",
                  "x.greaterEqual(0)",
                  "y.lesserEqual(" + this.config.pixelsY + ")",
                  "y.greaterEqual(0)",
                  "createdAt.greater(" + json.syncAt + ")",
                ],
                100,
                undefined,
                cursor,
                "after"
              );

              documents.push(...response.documents);

              if (response.documents.length > 0) {
                cursor = response.documents[response.documents.length - 1].$id;
              } else {
                hasNext = false;
              }
            } while (hasNext);

            return documents;
          },

          async fetchUsingDatabase() {
            documents = [];

            let cursor = undefined;
            hasNext = true;
            do {
              const response = await appwrite.database.listDocuments(
                "pixelsPublic",
                [
                  "x.lesserEqual(" + this.config.pixelsX + ")",
                  "x.greaterEqual(0)",
                  "y.lesserEqual(" + this.config.pixelsY + ")",
                  "y.greaterEqual(0)",
                ],
                100,
                undefined,
                cursor,
                "after"
              );

              documents.push(...response.documents);

              if (response.documents.length > 0) {
                cursor = response.documents[response.documents.length - 1].$id;
              } else {
                hasNext = false;
              }
            } while (hasNext);

            return documents;
          },

          async fetchPixels() {
            documents = [];

            try {
              documents = await this.fetchUsingStorage();
            } catch (err) {
              console.error(err);
              alert(err.message);
            }

            for (const document of documents) {
              if (!this.state.pixels[document.$id]) {
                if (document.hex === "ffffff") {
                  if (this.state.pixels[document.$id]) {
                    delete this.state.pixels[document.$id];
                  }
                } else {
                  this.state.pixels[document.$id] = document;
                }
              }
            }

            this.render(true);
            this.calculateCenter();
          },

          calculateCenter() {
            const pixelSize = 1 * this.state.zoom;

            const k = this.state.zoom * (500 / 2);
            const left = -(this.state.posX - k);
            const top = -(this.state.posY - k);

            this.state.currentPixelPos = [
              Math.floor(left / pixelSize),
              Math.floor(top / pixelSize),
            ];

            if (this.state.previousPixelPosition !== null) {
              this.sketch.set(
                this.state.previousPixelPosition[0],
                this.state.previousPixelPosition[1],
                this.state.previousPixelColor
              );
              this.sketch.updatePixels();
            }

            const currentPixelColor = this.sketch.get(
              this.state.currentPixelPos[0],
              this.state.currentPixelPos[1]
            );

            const tinyColor = tinycolor(
              `rgb(${currentPixelColor[0]}, ${currentPixelColor[1]}, ${currentPixelColor[2]})`
            );

            let darkerPixelColorHex;
            if (tinyColor.isLight()) {
              darkerPixelColorHex = tinyColor.darken(35).toString();
            } else {
              darkerPixelColorHex = tinyColor.brighten(35).toString();
            }

            const clr = this.sketch.color(darkerPixelColorHex);
            this.sketch.set(
              this.state.currentPixelPos[0],
              this.state.currentPixelPos[1],
              clr
            );
            this.sketch.updatePixels();

            this.state.previousPixelColor = currentPixelColor;
            this.state.previousPixelPosition = this.state.currentPixelPos;

            const currentCursorPixel =
              this.state.pixels[
                `${this.state.currentPixelPos[0]}_${this.state.currentPixelPos[1]}`
              ];

            this.state.currentPixelShow = currentCursorPixel !== undefined;
            this.state.currentPixelData =
              currentCursorPixel === undefined
                ? this.state.currentPixelData
                : currentCursorPixel;
          },

          onMouseDown(event) {
            this.state.isDragging = true;
          },

          onMouseUp(event) {
            this.state.isDragging = false;
          },

          onTouchStart(event) {
            this.state.lastTouch = {
              x: event.touches[0].screenX,
              y: event.touches[0].screenY,
            };
          },

          onTouchEnd(event) {
            this.state.lastTouch = null;
          },

          onTouchMove(event) {
            event.preventDefault();
            event.stopPropagation();

            if (!this.state.lastTouch) {
              return;
            }

            const moveX = event.touches[0].screenX - this.state.lastTouch.x;
            const moveY = event.touches[0].screenY - this.state.lastTouch.y;

            this.state.posX += moveX;
            this.state.posY += moveY;

            this.calculateCenter();

            this.state.lastTouch = {
              x: event.touches[0].screenX,
              y: event.touches[0].screenY,
            };
          },

          onMouseMove(event) {
            if (!this.state.isDragging) {
              return;
            }

            const { movementY, movementX } = event;

            this.state.posX += event.movementX;
            this.state.posY += event.movementY;

            this.calculateCenter();
          },

          onScroll(event) {
            const originalDistance = this.state.zoom;

            let scroll = -event.deltaY;
            this.state.zoom += scroll / 200;

            this.checkZoom(originalDistance);

            event.preventDefault();
            event.stopPropagation();
          },

          init() {
            appwrite.subscribe(
              ["collections.pixelsPublic.documents"],
              (event) => {
                let d = Date.now();
                let isAction = false;
                let actionColor = null;
                let actionPos = null;

                if (
                  event.event === "database.documents.update" ||
                  event.event === "database.documents.create"
                ) {
                  if (event.payload.hex === "ffffff") {
                    if (this.state.pixels[event.payload.$id]) {
                      delete this.state.pixels[event.payload.$id];

                      isAction = true;
                      actionColor = "ffffff";
                      actionPos = event.payload.$id.split("_");
                    }
                  } else {
                    this.state.pixels[event.payload.$id] = event.payload;

                    isAction = true;
                    actionColor = event.payload.hex;
                    actionPos = event.payload.$id.split("_");
                  }
                }

                if (isAction) {
                  const pixelSize = 1 * this.state.zoom;

                  const k = this.state.zoom * (500 / 2);
                  const left = -(this.state.posX - k);
                  const top = -(this.state.posY - k);

                  const currentPos = [
                    Math.floor(left / pixelSize),
                    Math.floor(top / pixelSize),
                  ];

                  if (
                    +actionPos[0] == currentPos[0] &&
                    +actionPos[1] === currentPos[1]
                  ) {
                    this.state.previousPixelColor = this.sketch.color(
                      "#" + actionColor
                    );
                    this.calculateCenter();
                  }

                  const clr = this.sketch.color("#" + actionColor);
                  this.sketch.set(actionPos[0], actionPos[1], clr);
                  this.sketch.updatePixels();
                }
              }
            );

            setTimeout(() => {
              const s = (sketch) => {
                sketch.setup = () => {
                  var canvas = sketch.createCanvas(500, 500);

                  canvas.parent("appboard");

                  this.canvas = canvas;
                  this.sketch = sketch;

                  this.sketch.noStroke();

                  this.fetchPixels();
                };

                // DO NOT USE
                sketch.draw = () => {};

                sketch.keyPressed = (event) => {
                  if (
                    event.target.nodeName.toLowerCase() !== "canvas" &&
                    event.target.nodeName.toLowerCase() !== "body"
                  ) {
                    return;
                  }

                  if (event.key === " ") {
                    this.onColorPixel();
                    return;
                  }

                  if (!isNaN(event.key)) {
                    const colorIndex = +event.key - 1;
                    this.state.selectedColor = this.config.colors[colorIndex];
                    return;
                  }

                  let moveX = 0;
                  let moveY = 0;

                  if (
                    event.key === "A" ||
                    event.key === "a" ||
                    event.key === "ArrowLeft"
                  ) {
                    moveX = 1;
                  }

                  if (
                    event.key === "D" ||
                    event.key === "d" ||
                    event.key === "ArrowRight"
                  ) {
                    moveX = -1;
                  }

                  if (
                    event.key === "W" ||
                    (event.key === "w") | (event.key === "ArrowUp")
                  ) {
                    moveY = 1;
                  }

                  if (
                    event.key === "S" ||
                    event.key === "s" ||
                    event.key === "ArrowDown"
                  ) {
                    moveY = -1;
                  }

                  if (event.shiftKey) {
                    moveX *= 3;
                    moveY *= 3;
                  }

                  this.state.posX += moveX * this.state.zoom;
                  this.state.posY += moveY * this.state.zoom;
                  this.calculateCenter();
                };
              };

              this.p5 = new p5(s);
            }, 1);
          },

          toggleInfo() {
            this.state.showInfoAlert = !this.state.showInfoAlert;
          },

          toggleOverlays() {
            this.state.overlaysHidden = !this.state.overlaysHidden
          },

          toggleTheme() {
            if (localStorage.theme === 'dark') {
              localStorage.theme = 'light';
            } else if (localStorage.theme === 'light') {
              localStorage.theme = 'dark';
            } else if (!localStorage.includes('theme')) {
              localStorage.theme = 'light';
            }

            updateTheme();
          },

          goToCenter() {
            this.state.posX = 0;
            this.state.posY = 0;
            this.calculateCenter();
          },

          exportScreenshot() {
            const s = (sketch) => {
              sketch.setup = () => {
                const { pixels } = this.state;
                const { pixelsX, pixelsY } = this.config;

                const canvas = sketch.createCanvas(pixelsX, pixelsY);
                sketch.pixelDensity(1);

                const clrBackground = sketch.color("#ffffff");
                for (let x = 0; x < pixelsX; x++) {
                  for (let y = 0; y < pixelsY; y++) {
                    sketch.set(x, y, clrBackground);
                  }
                }

                for (const pixel in pixels) {
                  const pixelData = pixels[pixel];
                  const clr = sketch.color("#" + pixelData.hex);
                  sketch.set(pixelData.x, pixelData.y, clr);
                }

                sketch.updatePixels();

                const currentDate = new Date();
                const fileName = currentDate.getFullYear() + currentDate.getMonth() + currentDate.getDate() + '_' +
                                 currentDate.getHours() + '-' + currentDate.getMinutes() + '-' + currentDate.getSeconds();
                const fileExtension = "png";

                sketch.saveCanvas(canvas, fileName, fileExtension);
                alert("A copy of the canvas has been saved to your Downloads folder.");
              };
            };

            const p5Screenshot = new p5(s);
          },

          zoomOut() {
            const originalDistance = this.state.zoom;
            this.state.zoom /= 1.5;

            this.checkZoom(originalDistance);
          },

          zoomIn() {
            const originalDistance = this.state.zoom;
            this.state.zoom *= 1.5;

            this.checkZoom(originalDistance);
          },

          checkZoom(originalZoom) {
            if (this.state.zoom < 1) {
              this.state.zoom = 1;
            }
            if (this.state.zoom > 100) {
              this.state.zoom = 100;
            }

            const originalWidth = +document
              .querySelector("#defaultCanvas0")
              .style.width.split("px")[0];
            const originalHeight = +document
              .querySelector("#defaultCanvas0")
              .style.height.split("px")[0];

            const newWidth = 500 * this.state.zoom;
            const newHeight = 500 * this.state.zoom;

            document.querySelector("#defaultCanvas0").style.width =
              newWidth + "px";
            document.querySelector("#defaultCanvas0").style.height =
              newHeight + "px";

            const originalDistance = this.distanceFromCenter(
              this.state.posX,
              this.state.posY,
              originalZoom
            );
            const newDistance = this.distanceFromCenter(
              this.state.posX,
              this.state.posY,
              this.state.zoom
            );

            const diffX = originalDistance[0] - newDistance[0];
            const diffY = originalDistance[1] - newDistance[1];

            this.state.posX += diffX;
            this.state.posY += diffY;

            this.calculateCenter();
          },

          distanceFromCenter(x, y, zoom) {
            const middleX = zoom * (500 / 2);
            const middleY = zoom * (500 / 2);

            const diffX = middleX - (x + 500 / 2) * zoom;
            const diffY = middleY - (y + 500 / 2) * zoom;

            return [diffX / this.state.zoom, diffY / this.state.zoom];
          },

          render(forced = false) {
            const { pixelsX, pixelsY } = this.config;

            if (!forced && !this.state.isReady) {
              return;
            }

            this.state.isReady = true;

            //          this.sketch.pixelDensity(1);
            const clrBackground = this.sketch.color("#ffffff");
            for (let x = 0; x < pixelsX; x++) {
              for (let y = 0; y < pixelsY; y++) {
                this.sketch.set(x, y, clrBackground);
              }
            }

            this.renderPixels();

            this.sketch.updatePixels();
          },

          printDate(date) {
            if (!date) {
              return "No date";
            }

            const d = new Date(date);

            const min =
              d.getMinutes() < 10 ? "0" + d.getMinutes() : d.getMinutes();
            const hour = d.getHours() < 10 ? "0" + d.getHours() : d.getHours();
            const day = d.getDate() < 10 ? "0" + d.getDate() : d.getDate();
            let m = d.getMonth() + 1;
            const month = m < 10 ? "0" + m : m;

            return `${day}.${month} at ${hour}:${min}`;
          },

          renderPixels() {
            const { pixels } = this.state;

            for (const pixel in pixels) {
              const pixelData = pixels[pixel];
              const clr = this.sketch.color("#" + pixelData.hex);
              this.sketch.set(pixelData.x, pixelData.y, clr);
            }
          },
        };
      }

      const app = alpineSetup();
    </script>
  </head>
  <body class="overflow-hidden">
    <div x-data="app">
      <div class="fixed bg-gray-100 dark:bg-slate-900 inset-0 bg-primary custom-bg z-[5]"></div>

      <div class="relative z-10 flex flex-col min-h-screen px-3 min-w-screen">
        <div
          class="relative z-20 flex flex-col items-center justify-center h-[100vh]"
        >
          <div
            x-show="!state.isReady"
            class="flex-shrink-0 flex items-center mb-2 justify-center space-x-3"
          >
            <h1 class="text-black dark:text-white font-bold text-3xl text-center">
              Almost Reddit Place
            </h1>

            <template hidden x-if="!state.isReady">
              <svg
                class="w-6 h-6 animate-spin text-black dark:text-white"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
            </template>
          </div>

          <template hidden x-if="!state.isReady">
            <p
              class="flex-shrink-0 mt-2 text-black dark:text-white font-bold text-lg text-center"
            >
              From time to time, we need to load a big file. Please be patient
              if load takes up to a minute.
            </p>
          </template>

          <div
            style="display: none;"
            x-show="state.isReady"
            class="h-full mt-3 touch-manipulation w-full bg-gray-200 dark:bg-slate-800 rounded-xl overflow-hidden relative"
          >
            <div
              x-show="state.currentPixelShow"
              x-transition:enter="transition ease-out duration-300"
              x-transition:enter-start="opacity-0 scale-90"
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-300"
              x-transition:leave-start="opacity-100 scale-100"
              x-transition:leave-end="opacity-0 scale-90"
              class="pointer-events-none absolute -space-y-1 flex-col z-10 bottom-4 left-0 w-full flex items-center justify-center"
            >
              <div
                x-text="state.currentPixelData ? printDate(state.currentPixelData.createdAt) : ''"
                class="p-1 px-2 text-xs text-slate-200 bg-slate-500 rounded-lg"
              ></div>
              <div
                x-text="state.currentPixelData ? state.currentPixelData.userId : ''"
                class="p-2 text-sm text-slate-500 bg-slate-900 rounded-lg"
              ></div>
            </div>

            <div class="relative h-full overflow-hidden bg-gray-200 dark:bg-slate-800">
              <div class="z-10 absolute w-full top-4 items-center justify-center flex flex-col space-y-4">
                <div
                  x-show="!state.overlaysHidden"
                  x-text="'x:' + state.currentPixelPos[0] + ' y:' + state.currentPixelPos[1]"
                  class="p-3 rounded-full text-black dark:text-white bg-gray-200/75 dark:bg-slate-700/75"
                ></div>
              </div>

              <div class="z-10 absolute top-4 left-4 flex flex-col space-y-4">
                <button
                  x-show="!state.overlaysHidden"
                  x-on:click="toggleInfo()"
                  class="p-3 rounded-full bg-gray-100 dark:bg-slate-700 text-black dark:text-white hover:bg-gray-300 dark:hover:bg-slate-900"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z"
                      clip-rule="evenodd"
                    />
                  </svg>
                </button>

                <button
                  x-show="!state.overlaysHidden"
                  x-on:click="goToCenter()"
                  class="p-3 rounded-full bg-gray-100 dark:bg-slate-700 text-black dark:text-white hover:bg-gray-300 dark:hover:bg-slate-900"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z"
                      clip-rule="evenodd"
                    />
                  </svg>
                </button>

                <button
                  x-show="!state.overlaysHidden"
                  x-on:click="exportScreenshot()"
                  class="p-3 rounded-full bg-gray-100 dark:bg-slate-700 text-black dark:text-white hover:bg-gray-300 dark:hover:bg-slate-900"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      transform="matrix(0.15710919,0,0,0.15752993,-0.04713276,-0.08174882)"
                      d="M 115.5,26.7 H 94.3 L 85.2,17.2 C 83.1,13.4 79,11.1 74.6,11.1 H 53.9 c -4.4,0 -8.5,2.4 -10.6,6.1 l -9.2,9.5 H 12.5 C 5.8,26.7 0.3,32 0.3,38.6 V 105 c 0,6.6 5.4,11.9 12.2,11.9 h 102.9 c 6.7,0 12.2,-5.3 12.2,-11.9 V 38.7 c 0,-6.6 -5.4,-12 -12.1,-12 z M 64,101.2 C 46.4,101.2 32.1,86.9 32.1,69.3 32.1,51.7 46.4,37.4 64,37.4 81.6,37.4 95.9,51.7 95.9,69.3 95.8,87 81.6,101.2 64,101.2 Z M 64,48.1 C 52.3,48.1 42.8,57.6 42.8,69.3 42.8,81 52.3,90.5 64,90.5 75.7,90.5 85.2,81 85.2,69.3 85.2,57.6 75.7,48.1 64,48.1 Z"
                    />
                  </svg>
                </button>
              </div>

              <div class="z-10 absolute top-4 right-4 flex flex-col space-y-4">
                <!-- Temporarily disabled button for hiding overlays -->
                <!-- <button
                  x-on:click="toggleOverlays()"
                  class="p-3 rounded-full bg-gray-100 dark:bg-slate-700 text-black dark:text-white hover:bg-gray-300 dark:hover:bg-slate-900"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="currentColor"
                    stroke="currentColor"
                  >
                    <path d="m0,10a15,28 0 0,0 20,0 15,28 0 0,0-20,0m14.4 0a4.5,4.5 0 1,1 0-.1zm-2,0a2.4,2.4 0 1,0 0 .1z"/>
                  </svg>
                </button> -->
                <button
                  x-show="!state.overlaysHidden"
                  x-on:click="toggleTheme()"
                  class="p-3 rounded-full bg-gray-100 dark:bg-slate-700 text-black dark:text-white hover:bg-gray-300 dark:hover:bg-slate-900"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="currentColor"
                    stroke="currentColor"
                  >
                    <path d="m 9.5624,5e-4 v 3.412383 h 0.8938 V 5e-4 Z m -3.9436,0.974995 -0.7564,0.474998 1.8,2.887585 0.7564,-0.468797 z m 8.8374,0.0875 -1.65,2.981185 0.7876,0.437398 1.6438,-2.981185 -0.7814,-0.437498 z M 1.7312,4.312978 1.29372,5.100574 4.26232,6.750566 4.69992,5.96937 1.73112,4.312978 Z m 8.2812,0.1314 c -3.05,0 -5.5248,2.483387 -5.5248,5.543772 0,3.059985 2.4748,5.544172 5.5248,5.543572 3.048,0 5.5188,-2.483187 5.5188,-5.543572 0,-3.060385 -2.4712,-5.543772 -5.5188,-5.543772 z m 8.35,0.106199 -2.9436,1.706192 0.4436,0.781396 2.9438,-1.706392 z M 0,9.288154 v 0.893595 H 3.4 V 9.288154 Z m 16.6,0.05 V 10.23815 H 20 V 9.338153 Z M 3.8812,12.475538 1,14.281729 l 0.46876,0.762596 2.8812,-1.812591 -0.4688,-0.756196 z m 12.1,0.193799 -0.4374,0.781196 2.975,1.656191 0.4374,-0.787396 z m -2.2624,2.724986 -0.775,0.443798 1.7,2.956185 0.775,-0.449998 z m -7.4312,0.0186 -1.65,2.987585 0.7812,0.431198 1.65,-2.987385 z m 3.2186,1.175194 V 20.0005 H 10.4 v -3.412383 z"/>
                  </svg>
                </button>
                <button
                  x-show="!state.overlaysHidden"
                  x-on:click="zoomIn()"
                  class="p-3 rounded-full bg-gray-100 dark:bg-slate-700 text-black dark:text-white hover:bg-gray-300 dark:hover:bg-slate-900"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"
                    />
                  </svg>
                </button>
                <button
                  x-show="!state.overlaysHidden"
                  x-on:click="zoomOut()"
                  class="p-3 rounded-full bg-gray-100 dark:bg-slate-700 text-black dark:text-white hover:bg-gray-300 dark:hover:bg-slate-900"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"
                    />
                  </svg>
                </button>
              </div>

              <div
                x-on:wheel="onScroll($event)"
                x-on:mousedown="onMouseDown($event)"
                x-on:mouseup="onMouseUp($event)"
                x-on:mousemove="onMouseMove($event)"
                x-on:touchmove="onTouchMove($event)"
                x-on:touchend="onTouchEnd($event)"
                x-on:touchcancel="onTouchEnd($event)"
                x-on:touchstart="onTouchStart($event)"
                class="w-full h-full flex items-center justify-center"
              >
                <div
                  class="w-full h-full flex items-center justify-center"
                  id="appboard"
                  x-bind:style="'transform: translate(' + state.posX + 'px, ' + state.posY + 'px)'"
                ></div>
              </div>
            </div>
          </div>

          <div
            style="display: none;"
            x-show="state.isReady"
            class="flex-shrink-0 mt-3 mb-3 w-full bg-gray-200 dark:bg-slate-800 rounded-xl p-4 grid grid-cols-12 gap-4"
          >
            <div
              class="overflow-x-auto col-span-12 md:col-span-8 flex flex-row space-x-3 items-center h-full"
            >
              <template x-for="(color, i) in config.colors" :key="i">
                <div class="relative flex items-center justify-center h-full">
                  <template x-if="state.selectedColor === color">
                    <div
                      class="pointer-events-none absolute left-0 top-0 h-full items-center w-full flex justify-center"
                    >
                      <div
                        class="p-[3px] rounded-full bg-slate-900 border-white flex items-center justify-center text-white"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          class="h-3 w-3"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                          stroke-width="2"
                        >
                          <path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="M5 13l4 4L19 7"
                          />
                        </svg>
                      </div>
                    </div>
                  </template>

                  <button
                    x-on:click="state.selectedColor = color"
                    x-bind:class="state.selectedColor === color ? 'border-2 border-black dark:border-slate-900' : 'border border-black dark:border-slate-700'"
                    class="rounded-lg w-10 h-10"
                    x-bind:style="'background-color:' + color"
                  ></button>
                </div>
              </template>
            </div>

            <template
              hidden
              x-data="{loaded: false}"
              x-init="setTimeout(() => { loaded = true }, 1)"
              x-if="loaded"
            >
              <div class="col-span-12 md:col-span-4">
                <template hidden x-if="$store.authModal.accountProfile">
                  <button
                    x-on:click="onColorPixel()"
                    x-bind:class="state.cooldown <= 0 ? 'dark:bg-slate-700 dark:hover:bg-slate-900 hover:bg-gray-300 bg-gray-100' : 'dark:bg-slate-700 bg-gray-50 opacity-50 cursor-not-allowed'"
                    class="flex items-center justify-center space-x-3 dark:text-white text-black w-full rounded-xl py-3 px-9"
                  >
                    <template hidden x-if="state.cooldown <= 0"
                      ><p>Color Pixel</p></template
                    >

                    <template hidden x-if="state.cooldown > 0"
                      ><p
                        x-text="'Color in ' + state.cooldown + (state.cooldown <= 1 ? ' second' : ' seconds')"
                      ></p
                    ></template>

                    <template hidden x-if="state.isColoring">
                      <svg
                        class="w-4 h-4 animate-spin black dark:text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          class="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          stroke-width="4"
                        ></circle>
                        <path
                          class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                    </template>
                  </button>
                </template>

                <template hidden x-if="!$store.authModal.accountProfile">
                  <button
                    x-on:click="$store.authModal.open()"
                    class="flex items-center justify-center space-x-3 text-black dark:text-white dark:bg-slate-700 dark:hover:bg-slate-900 hover:bg-gray-300 bg-gray-100 w-full rounded-xl py-3 px-9"
                  >
                    <p>Sign in</p>

                    <template hidden x-if="state.isColoring">
                      <svg
                        class="w-4 h-4 animate-spin text-white"
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                      >
                        <circle
                          class="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          stroke-width="4"
                        ></circle>
                        <path
                          class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        ></path>
                      </svg>
                    </template>
                  </button>
                </template>
              </div>
            </template>
          </div>
        </div>
      </div>

      <div
        x-show="state.showInfoAlert"
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="opacity-0"
        x-transition:enter-end="opacity-100"
        x-transition:leave="transition ease-in duration-300"
        x-transition:leave-start="opacity-100"
        x-transition:leave-end="opacity-0"
        class="fixed z-[9999] inset-0"
        style="display: none; font-family: 'Montserrat', sans-serif"
      >
        <div class="w-full h-full relative">
          <div
            class="absolute inset-0 bg-black opacity-50"
            x-on:click="toggleInfo()"
          ></div>
          <div
            class="relative w-full h-full pt-10 overflow-y-auto pb-10"
            x-on:click="toggleInfo()"
          >
            <div
              class="mx-auto w-full max-w-2xl rounded-xl bg-gray-200 dark:bg-slate-800 p-6 text-black dark:text-white"
              x-on:click="$event.stopPropagation()"
            >
              <div class="flex justify-between items-center">
                <h1 class="text-auth-gray-900 mb-4 text-2xl font-bold">
                  Getting Started
                </h1>
                <button
                  type="button"
                  x-on:click="toggleInfo()"
                  class="p-3 transition-colors duration-200 transform rounded-md hover:bg-opacity-25 hover:bg-gray-600 focus:outline-none"
                >
                  <svg
                    class="w-5 h-5"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      d="M6 18L18 6M6 6L18 18"
                      stroke="currentColor"
                      stroke-width="2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    ></path>
                  </svg>
                </button>
              </div>
              <div class="mt-6 prose">
                <p>Welcome to Almost Reddit Place 👋</p>

                <p>
                  I decided to create this project to showcase what
                  <a
                    href="https://appwrite.io/docs/installation"
                    class="text-[#f02e65]"
                    >Appwrite</a
                  >
                  is capable of and learn how to work with canvas on a website.
                  I took the idea from Reddit Place, where the Reddit team added
                  a minigame similar to this one for a few weeks after April
                  Fools' Day 🤪
                </p>

                <p>
                  In this game, anyone can color 1 pixel of 500x500 canvas every
                  10 seconds. There is a palette of colors you can pick from to
                  create your masterpiece. If you want to work on a big
                  painting, feel free to invite your friends to help you 🖼️
                </p>

                <p>
                  You are currently using the remade version by
                  <a class="text-[#f02e65]" href="https://github.com/DwarflinDeveloping/">DwarflinDeveloping</a>.
                  For the original version <a class="text-[#f02e65]" href="https://github.com/Meldiron/almost-reddit-place/">click here</a>.
                </p>

                <i class="italic"
                  >Fun fact: Appwrite implementation took less than 2 hours!</i
                >

                <h3>✨ Tips and Tricks</h3>

                <ul>
                  <li>
                    Center of the canvas is your cursor. This means that if you
                    paint a pixel, it will paint the one in the middle of the
                    canvas. You can drag&drop with your mouse to move around the
                    canvas to move this cursor. The cursor is visible, so there
                    shouldn't be any problem painting any pixel you want. If it
                    feels tricky selecting a specific pixel, you can zoom in to
                    make it easier.
                  </li>
                  <li>
                    If you focus inside canvas (click it), you can now use WASD
                    (or arrows) to move around. Hold SHIFT to move 3 pixels
                    instead of one. You can also use numbers on the keyboard to
                    switch colors and press SPACE to paint the pixel.
                  </li>
                  <li>
                    If you paint the pixel white, it resets the pixel. You won't
                    see your name on such a pixel, it will become an empty
                    pixel.
                  </li>
                  <li>
                    If you register, the first part of your email becomes your
                    username. The username is publicly visible, so feel free to
                    create a fake account if you don't want to share your email.
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
